% Copyright 2020 Christopher Khan, Kazuyuki Dei, Siegfried Schlunk, and
% Brett Byram

% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the license at

%     http://www.apache.org/licenses/LICENSE-2.0

% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and 
% limitations under the License.


% Description of ADMIRE_models_generation_main.m:
% This script is the main program for generating the ADMIRE models


% Clear the workspace and close all figures
clear all; close all;


%% User-Defined Parameters %%
% Define the input parameters (the parameters in the User-Defined Parameters section are the only parameters that need to be changed by the user)
params.processor_type = 'GPU';            % Specify the type of processor that the ADMIRE models will be used on: Specify either 'CPU' or 'GPU' (the ADMIRE models are always generated by running this code on a CPU, but processing channel data with ADMIRE can be done using either a CPU or a GPU)
params.data_type = 'Reshaped';            % Specify the type of data that is being processed: Specify either 'Reshaped' or 'Verasonics RF Buffer' ('Reshaped' means that the data is in the form (Depths + t0 - 1) x Elements per Beam x Beams x Frames, and 'Verasonics RF Buffer' means that the data is of type int16 and in the form Buffer Rows x Total Elements On Transducer x Frames because on the Verasonics, all of the transducer elements are used to receive for the RF data buffer)
params.t0 = 1;                            % The axial sample index that corresponds to a depth of 0: The axial samples corresponding to indices less than t0 will be removed (set t0 to 1 when the t0 is already accounted for in the data)
params.c = 1540;                          % Speed of sound (m/s)
params.num_buffer_rows = 0;               % The number of rows per frame in the Verasonics RF buffer: Not used when data_type = 'Reshaped'
params.num_depths = 2000;                 % Number of depth samples in the channel data after t0 is accounted for
params.num_elements = 128;                % Number of receive elements used to obtain one beam
params.total_elements_on_probe = 256;     % Total number of elements that are on the transducer
params.num_beams = 128;                   % Number of beams
params.f0 = 5.8125E6;                     % Transducer center frequency (Hz)
params.fs = 23.25E6;                      % Sampling frequency (Hz)
params.BW = 0.6;                          % Fractional bandwidth of transmitted pulse
params.probe_type = 'Linear';             % Type of transducer array used: Specify either 'Linear' or 'Curvilinear'
params.probe_name = 'Field II Linear Transducer Array'; % Name of transducer array (i.e., 'L7-4', 'C5-2', etc.)
params.probe_radius = 0;                  % Curved transducer array radius (m): Not used when probe_type = 'Linear'
params.dtheta = 0;                        % Angle increment (rad) between beams: Not used when probe_type = 'Linear'
params.probe_pitch = 1.953E-4;            % Pitch of the transducer array (m)
params.start_depth_ADMIRE = 0;            % The start depth for applying ADMIRE (m): If the start depth is less than the minimum depth for the scan, then the start depth is set to the minimum depth automatically
params.end_depth_ADMIRE = 10;             % The end depth for applying ADMIRE (m): If the end depth is greater than the maximum depth for the scan, then the end depth is set to the maximum depth automatically 
params.alpha = 0.9;                       % The alpha that is used for elastic-net regularization: The range for this value is [0, 1]
params.lambda_scaling_factor = 0.0189;    % Scaling factor that is used in the calculation of lambda, which is used in elastic-net regularization
params.max_iterations = 100000;           % The maximum number of iterations of cyclic coordinate descent to perform (convergence criterion)
params.tolerance = 0.1;                   % The maximum weighted (observation weights are all 1 in this case) sum of squares of the changes in the fitted values between iterations of cyclic coordinate descent (convergence criterion)
params.ICA_ADMIRE_flag = 1;               % Set to 0 for full model ADMIRE or set to 1 for ICA model ADMIRE (Must set to 1 if processor_type = 'GPU')
params.channel_data_output_flag = 1;      % Set to 0 to only have the envelope data outputted when the ADMIRE models are applied or set to 1 to have both the envelope data and channel data outputted when the ADMIRE models are applied
params.aperture_growth_flag = 1;          % Set to 0 to not perform aperture growth or set to 1 to perform aperture growth
params.min_num_elements = 16;             % This parameter does not let aperture growth reduce the number of elements below the parameter's value: Not used when aperture_growth_flag = 0
params.F_number = 2;                      % F number for applying aperture growth: Not used when aperture_growth_flag = 0
params.models_save_path = 'enter path here';  % Path to the directory in which the generated models are saved to

% Define parameters that can be modified but are recommended to be left
% unmodified
params.max_windows_per_set = 17;            % Number of windows to group together in one set for the STFT calculation on the GPU: Not used if processor_type = 'CPU'
params.pulse_multiplier = 1;                % Scaling factor that is used in the stft_window_length parameter calculation
params.cal_shift = 7.75E-6;                 % Calibration offset (m) used for the tau_n0 calculation in the generate_modeled_signal_for_predictor function
params.distance_offset_shift = 3.85E-5;     % Calibration offset (m) used for the distance offset in the generate_modeled_signal_for_predictor function 
params.win_tune = 1;                        % Scaling factor that is multiplied by the half_pulse_length_distance variable in the generate_modeled_signal_for_predictor function
params.ellipsoid_constant_1 = 0;            % Constant that is used in the ellipsoidal acceptance region calculation in the generate_models_for_stft_window function
params.ellipsoid_constant_2 = 0.5E-3 + eps; % Constant that is used in the ellipsoidal acceptance region calculation in the generate_models_for_stft_window function
params.lateral_limit_offset = 1E-3;         % Calibration offset (m) that is used in calculating the possible lateral positions for the outer model predictors in the generate_models_for_stft_window function

% Define parameters that must be set to current values in this code release
params.stft_window_overlap = 0;             % The fraction of samples that overlap between STFT windows (Must set to 0)
params.gamma_im = 0;                        % Gamma parameter that is used for intentional modulation (Must set to 0)
params.stft_windowing_function = @rectwin;  % Windowing function to use for the STFT (must set to @rectwin)

% Define the parameters that are used to define the model space for ADMIRE
% (these parameters can be changed if a different model space sampling is
% desired). These scaling factors and constants can be ignored, and the
% models can be hard-coded by the user using their own sampling grids by
% modifying the respective lines of code in the
% generate_models_for_stft_window function. However, this approach is not
% recommended. The variables that can be hard-coded are in the sections
% that are commented as being able to be hard-coded in the
% generate_models_for_stft_window function.
params.ROI_model_x_position_scaling_factors = [-0.5, 0.0179, 0.5];              % Scaling factors that are used to define the possible lateral positions of the ROI model predictors in the generate_models_for_stft_window function
params.ROI_model_z_position_scaling_factors = [-0.5, 0.1430, 0.5];              % Scaling factors that are used to define the possible depth positions of the ROI model predictors in the generate_models_for_stft_window function
params.ROI_model_distance_offset_scaling_factor = [0.0485];                     % Scaling factor that is used to define the possible distance offsets for the ROI model predictors in the generate_models_for_stft_window function
params.ROI_model_distance_offset_constants = [-0.8E-3, 0.4E-3];                 % Constants that describe the minimum and maximum distance offsets (m) that are used for the ROI model predictors in the generate_models_for_stft_window function
params.outer_model_x_position_scaling_factors = [-1, 1.4228, 1];                % Scaling factors that are used to define the possible lateral positions for the outer model predictors in the generate_models_for_stft_window function
params.outer_model_z_position_scaling_factors = [0, 0, 0.7114, 1, 0, 0.05]; %[1, -0.5, 0.7114, 1, 0.5, 0];   % Scaling factors that are used to define the possible depth positions of the outer model predictors in the generate_models_for_stft_window function
params.outer_model_distance_offset_scaling_factor = [0.1211];                   % Scaling factor that is used to define the possible distance offsets for the outer model predictors in the generate_models_for_stft_window function
params.outer_model_z_position_constants = [0];                                  % Constant that is used to define the possible depth positions of the outer model for the predictors in the generate_models_for_stft_window function
params.outer_model_distance_offset_constants = [-8E-3, 3.2E-3];                 % Constants that describe the minimum and maximum distance offsets (m) that are used for the outer model predictors in the generate_models_for_stft_window function

% Display the formulas that are used to calculate the ROI and outer
% model spaces for ADMIRE based off of the parameters provided above, and
% store the formulas into the parameters structure
params = display_and_store_ADMIRE_model_space_formulas(params);


%% Removal Of Parameters That Are Not Used %%
% Remove the parameters that are not used if the data type is not
% Verasonics RF Buffer
if ~strcmp(params.data_type, 'Verasonics RF Buffer')
    fields_1 = {'num_buffer_rows'};
    params = rmfield(params, fields_1);
end

% Remove the parameters that are not used if the probe type is not curvilinear
if ~strcmp(params.probe_type, 'Curvilinear')
    fields_2 = {'probe_radius', 'dtheta'};
    params = rmfield(params, fields_2);
end

% Remove the parameters that are not used if aperture growth is not applied
if params.aperture_growth_flag == 0
    fields_3 = {'min_num_elements', 'F_number'};
    params = rmfield(params, fields_3);
end

% Remove the parameters that are not used if the ADMIRE models will not be
% used on a GPU
if ~strcmp(params.processor_type, 'GPU')
    fields_4 = {'max_windows_per_set'};
    params = rmfield(params, fields_4);
end


%% Depths Calculation %%
% Calculate the depths that correspond to each sample 
depths = [0:params.num_depths - 1] ./ params.fs .* (params.c ./ 2);

% Store the depths into the parameters structure
params.depths = depths;          % Depths corresponding to each sample (m)


%% Parameter Value Error Checking %%
% Call the function that checks to make sure that invalid parameter values
% are not entered
params = parameter_values_check(params);


%% STFT Parameter Calculation %%
% Calculate the STFT window length using a Gaussian model estimate of the
% pulse width
sff = ((params.BW .* params.f0) .^ 2) ./ (8 .* log(2));
stt = 1 ./ (4 .* (pi .^ 2) .* sff);
st = sqrt(stt);
pulse_FWHM = sqrt(8 .* log(2)) .* st;
half_pulse_width_samples = ceil(params.pulse_multiplier .* pulse_FWHM .* params.fs);
stft_window_length = half_pulse_width_samples;

% Calculate the zero-padded STFT window length
zero_padded_stft_window_length = 2 .* stft_window_length;

% Calculate the STFT window shift
stft_window_shift = round(stft_window_length .* (1 - params.stft_window_overlap));

% Calculate the number of STFT windows for one beam within the specified
% depth range for ADMIRE
stft_start_depth_inds = [1:stft_window_shift:params.num_depths];
stft_end_depth_inds = [stft_window_shift:stft_window_shift:params.num_depths];
min_num_inds = min(length(stft_start_depth_inds), length(stft_end_depth_inds));
stft_start_depth_inds = stft_start_depth_inds(1:min_num_inds);
stft_end_depth_inds = stft_end_depth_inds(1:min_num_inds);
stft_start_depths = params.depths(stft_start_depth_inds);
stft_end_depths = params.depths(stft_end_depth_inds);
stft_start_window_ind = find(stft_start_depths >= params.start_depth_ADMIRE);
stft_start_window_ind = stft_start_window_ind(1);
stft_end_window_ind = find(stft_end_depths <= params.end_depth_ADMIRE);
stft_end_window_ind = stft_end_window_ind(end);
stft_window_inds = [stft_start_window_ind:stft_end_window_ind];
stft_num_windows = length(stft_window_inds);

% Calculate the frequencies within each STFT window that will be used for
% ADMIRE
normalized_freqs = [0:zero_padded_stft_window_length - 1] ./ zero_padded_stft_window_length;
freqs = normalized_freqs .* params.fs;
sig_BW = params.f0 .* params.BW; 
minimum_freq_cutoff = params.f0 - (0.5 .* sig_BW .* 1.2);
maximum_freq_cutoff = params.f0 + (0.5 .* sig_BW .* 1.2);
selected_freqs = freqs(freqs >= minimum_freq_cutoff & freqs <= maximum_freq_cutoff);
rearranged_freqs = fftshift(freqs);
selected_freqs(selected_freqs > rearranged_freqs(end)) = [];  % This makes sure that none of the frequencies that actually correspond to the negative frequencies are used
selected_freqs_start_ind = find(selected_freqs(1) == freqs);
selected_freqs_end_ind = find(selected_freqs(end) == freqs);
selected_freq_inds = [selected_freqs_start_ind:selected_freqs_end_ind];

% Calculate the wavenumber values for the selected frequencies
k = (2 .* pi .* selected_freqs) ./ params.c;

% Store the STFT parameters into the parameters structure
params.half_pulse_width_samples = half_pulse_width_samples;              % The number of samples that are in half of the pulse
params.stft_window_length = stft_window_length;                          % STFT window length without zero padding
params.zero_padded_stft_window_length = zero_padded_stft_window_length;  % STFT window length with zero padding
params.stft_window_shift = stft_window_shift;                            % Number of depth samples to shift by when moving to the next STFT window
params.stft_num_windows = stft_num_windows;                              % Number of STFT windows for one beam
params.stft_start_depth_inds = stft_start_depth_inds;                    % Depth sample that the first sample in each STFT window corresponds to
params.stft_window_inds = stft_window_inds;                              % STFT window indices corresponding to ADMIRE depth range
params.selected_freqs = selected_freqs;                                  % Frequencies to which ADMIRE is applied to (Hz)
params.selected_freq_inds = selected_freq_inds;                          % Indices of selected frequencies within a STFT window
params.minimum_freq_cutoff = minimum_freq_cutoff;                        % Minimum frequency cutoff for selecting frequencies (Hz)
params.maximum_freq_cutoff = maximum_freq_cutoff;                        % Maximum frequency cutoff for selecting frequencies
params.k = k;                                                            % Wavenumber values corresponding to the selected frequencies (rad/m)


%% Model Generation For The Selected Frequencies In Each STFT Window %%
% Loop through the STFT windows and call the function that generates the
% models for all of the selected frequencies for each window
fprintf('Generation of ADMIRE models is beginning.\n');
for window_id = 1:params.stft_num_windows
    generate_models_for_stft_window(window_id, params);
    fprintf('STFT window #%d of %d is complete.\n', window_id, params.stft_num_windows);
end
fprintf('Generation of ADMIRE models is complete.\n');

%% Format ADMIRE Models For GPU %%
% Format the ADMIRE models if they are going to be applied on a GPU
% The formatted ADMIRE models are also saved out into the directory
% specified by params.models_save_path
fprintf('Formatting of ADMIRE models for GPU is beginning.\n');
if strcmp(params.processor_type, 'GPU')
    format_ADMIRE_models_for_GPU(params);
end
fprintf('Formatting of ADMIRE models for GPU is complete.\n');
